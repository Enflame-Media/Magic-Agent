# frozen_string_literal: true

# Fastfile - Build automation for Happy mobile app
# For more information: https://docs.fastlane.tools/

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

# Constants
APP_IDENTIFIER = "com.enflamemedia.happy"
WORKSPACE_NAME = "happyvue"

# Default platform
default_platform(:ios)

# Before all lanes
before_all do |lane|
  # Ensure we're in the right directory
  ensure_git_status_clean unless ENV["CI"]
end

# ============================================
# iOS Platform
# ============================================
platform :ios do
  desc "Prepare iOS build environment"
  private_lane :prepare_ios do
    # Set up CI keychain if running in CI
    if ENV["CI"]
      setup_ci

      # Create a temporary keychain for CI
      create_keychain(
        name: "fastlane_keychain",
        password: ENV["KEYCHAIN_PASSWORD"] || "temppass",
        default_keychain: true,
        unlock: true,
        timeout: 3600,
        lock_when_sleeps: false
      )
    end

    # Fetch certificates and profiles using Match
    match(
      type: "appstore",
      app_identifier: APP_IDENTIFIER,
      readonly: ENV["CI"] == "true",
      keychain_name: ENV["CI"] ? "fastlane_keychain" : nil,
      keychain_password: ENV["CI"] ? (ENV["KEYCHAIN_PASSWORD"] || "temppass") : nil
    )
  end

  desc "Build NativeScript iOS app"
  private_lane :build_nativescript_ios do
    # Navigate to app directory and build
    sh("cd .. && ns build ios --release --for-device --env.production")
  end

  desc "Build and sign iOS app for distribution"
  private_lane :build_ios_app do
    # Build the iOS app using gym (build_app)
    build_app(
      workspace: "../platforms/ios/#{WORKSPACE_NAME}.xcworkspace",
      scheme: WORKSPACE_NAME,
      export_method: "app-store",
      output_directory: "./build",
      output_name: "Happy.ipa",
      clean: true,
      include_bitcode: false,
      export_options: {
        provisioningProfiles: {
          APP_IDENTIFIER => "match AppStore #{APP_IDENTIFIER}"
        }
      }
    )
  end

  desc "Build and deploy to TestFlight"
  lane :beta do
    # Prepare environment
    prepare_ios

    # Build NativeScript app
    build_nativescript_ios

    # Build and sign
    build_ios_app

    # Upload to TestFlight
    upload_to_testflight(
      skip_waiting_for_build_processing: true,
      skip_submission: true,
      distribute_external: false,
      notify_external_testers: false,
      # Use App Store Connect API key (set via environment)
      api_key_path: ENV["APP_STORE_CONNECT_API_KEY_PATH"]
    )

    UI.success("Successfully uploaded to TestFlight!")
  end

  desc "Deploy to App Store (production)"
  lane :release do
    # First deploy to TestFlight
    beta

    # Then submit for review
    deliver(
      submit_for_review: true,
      automatic_release: false,
      force: true, # Skip HTML report verification
      skip_screenshots: true,
      skip_metadata: false,
      precheck_include_in_app_purchases: false,
      submission_information: {
        add_id_info_uses_idfa: false
      }
    )

    UI.success("Successfully submitted to App Store for review!")
  end

  desc "Sync certificates and profiles only (no build)"
  lane :sync_certificates do
    if ENV["CI"]
      setup_ci
    end

    match(
      type: "appstore",
      app_identifier: APP_IDENTIFIER,
      readonly: false
    )

    match(
      type: "development",
      app_identifier: APP_IDENTIFIER,
      readonly: false
    )

    UI.success("Certificates synced successfully!")
  end

  desc "Register new devices and update profiles"
  lane :register_device do |options|
    device_name = options[:name] || UI.input("Device name: ")
    device_udid = options[:udid] || UI.input("Device UDID: ")

    register_devices(
      devices: {
        device_name => device_udid
      }
    )

    # Regenerate development profiles with new device
    match(
      type: "development",
      app_identifier: APP_IDENTIFIER,
      force_for_new_devices: true
    )

    UI.success("Device registered and profiles updated!")
  end
end

# ============================================
# Android Platform
# ============================================
platform :android do
  desc "Build NativeScript Android app"
  private_lane :build_nativescript_android do
    # Build Android app with release signing
    keystore_path = ENV["KEYSTORE_PATH"] || "keystore.jks"

    sh(
      "cd .. && ns build android --release " \
      "--key-store-path #{keystore_path} " \
      "--key-store-password #{ENV['KEYSTORE_PASSWORD']} " \
      "--key-store-alias #{ENV['KEYSTORE_ALIAS']} " \
      "--key-store-alias-password #{ENV['KEY_PASSWORD']} " \
      "--aab " \
      "--env.production"
    )
  end

  desc "Build and deploy to Play Store internal track"
  lane :beta do
    # Build NativeScript app
    build_nativescript_android

    # Find the AAB file
    aab_path = "../platforms/android/app/build/outputs/bundle/release/app-release.aab"

    unless File.exist?(File.expand_path(aab_path, __dir__))
      UI.user_error!("AAB file not found at #{aab_path}")
    end

    # Upload to Play Store internal track
    upload_to_play_store(
      track: "internal",
      aab: aab_path,
      skip_upload_apk: true,
      skip_upload_metadata: true,
      skip_upload_changelogs: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      release_status: "draft", # or "completed" for immediate release
      json_key_data: ENV["SUPPLY_JSON_KEY_DATA"]
    )

    UI.success("Successfully uploaded to Play Store internal track!")
  end

  desc "Promote internal to production"
  lane :release do
    # Promote from internal to production
    upload_to_play_store(
      track: "internal",
      track_promote_to: "production",
      skip_upload_aab: true,
      skip_upload_apk: true,
      json_key_data: ENV["SUPPLY_JSON_KEY_DATA"]
    )

    UI.success("Successfully promoted to production!")
  end

  desc "Build APK for testing (not for store)"
  lane :build_apk do
    keystore_path = ENV["KEYSTORE_PATH"] || "keystore.jks"

    sh(
      "cd .. && ns build android --release " \
      "--key-store-path #{keystore_path} " \
      "--key-store-password #{ENV['KEYSTORE_PASSWORD']} " \
      "--key-store-alias #{ENV['KEYSTORE_ALIAS']} " \
      "--key-store-alias-password #{ENV['KEY_PASSWORD']} " \
      "--env.production"
    )

    UI.success("APK built successfully!")
    UI.message("APK location: platforms/android/app/build/outputs/apk/release/")
  end
end

# ============================================
# Cross-platform lanes
# ============================================
desc "Run all tests"
lane :test do
  sh("cd .. && npm run typecheck")
  sh("cd .. && npm run lint")
  UI.success("All tests passed!")
end

desc "Increment version number"
lane :bump_version do |options|
  bump_type = options[:type] || "patch" # patch, minor, or major

  # Update package.json version
  package_json = JSON.parse(File.read("../package.json"))
  current_version = package_json["version"]

  version_parts = current_version.split(".").map(&:to_i)

  case bump_type
  when "major"
    version_parts[0] += 1
    version_parts[1] = 0
    version_parts[2] = 0
  when "minor"
    version_parts[1] += 1
    version_parts[2] = 0
  when "patch"
    version_parts[2] += 1
  end

  new_version = version_parts.join(".")
  package_json["version"] = new_version

  File.write("../package.json", JSON.pretty_generate(package_json) + "\n")

  UI.success("Version bumped from #{current_version} to #{new_version}")
  new_version
end

# Error handling
error do |lane, exception|
  UI.error("Lane #{lane} failed with: #{exception.message}")

  # Clean up CI keychain if it exists
  if ENV["CI"]
    delete_keychain(name: "fastlane_keychain") if File.exist?(File.expand_path("~/Library/Keychains/fastlane_keychain-db"))
  end
end
